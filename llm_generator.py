from __future__ import annotations

import os
import json
import datetime as _dt
from typing import Any, Dict, Optional
from pathlib import Path
import os

# 型エイリアス
Dataset = Dict[str, Any]

_OPENAI_MISSING = (
    "OpenAI クライアントが見つかりません。'pip install openai' を実行し、"
    "環境変数 OPENAI_API_KEY を設定してください。"
)


def _load_env_once() -> None:
    """Load .env from this file's directory or its parent, without extra deps.

    Only sets variables that are not already present in os.environ.
    """
    try:
        def _apply(path: Path) -> None:
            if not path.exists():
                return
            for line in path.read_text(encoding="utf-8").splitlines():
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                if '=' not in line:
                    continue
                k, v = line.split('=', 1)
                k = k.strip()
                v = v.strip().strip('"').strip("'")
                if k and (k not in os.environ or not os.environ.get(k)):
                    os.environ[k] = v
        here = Path(__file__).resolve().parent
        _apply(here / ".env")
        _apply(here.parent / ".env")
    except Exception:
        pass


_load_env_once()


def _build_system_prompt() -> str:
    return (
        "You are a TOEIC-style reading question generator. "
        "Return ONLY a single JSON object in UTF-8 without any commentary. "
        "Schema: {title, version, language, explanationsLanguage, createdAt, parts:[{part, name, instructions, questions:[{id, context, stem?, options, answer, explanationJa}]}], metadata}. "
        "Constraints:\n"
        "- parts must contain exactly ONE part (5|6|7) with exactly ONE question.\n"
        "- options must be 3 (A–C) or 4 (A–D) strings, each labeled like 'A. text'.\n"
        "- answer must be one letter 'A'|'B'|'C'|'D'.\n"
        "- explanationJa must be detailed in Japanese (2–4 sentences), stating the rationale and why distractors are wrong.\n"
        "- For part 7, include context.passage; for part 6, context.text; for part 5, use stem.\n"
        "- Keep content original (no copyrighted exam content)."
    )


def _build_user_prompt(part: int, seed: int | None, p7_length: str, difficulty: str | None = None, genre: str | None = None, domain: str | None = None) -> str:
    today = _dt.date.today().isoformat()
    extra = []
    if difficulty:
        extra.append(f"difficulty: {difficulty} (easy|medium|hard); adjust vocabulary/complexity accordingly")
    if genre:
        extra.append(
            "genre: "
            f"{genre} "
            "(notice|advertisement|review|faq|schedule|press_release|policy|invoice|menu|event|weather|job_posting|parking|social_post|interview|newsletter|manual|recall_notice|minutes|survey); "
            "reflect the authentic document style concisely."
        )
    if domain:
        extra.append(
            "domain: "
            f"{domain} "
            "(it|manufacturing|logistics|medical|finance|hr|marketing|education|hospitality|retail|realestate|energy|legal|public|aviation|food|construction|ecommerce|support); "
            "use appropriate vocabulary/collocations from this domain."
        )
    extra_str = ("\n" + "\n".join(extra)) if extra else ""
    return (
        f"title: TOEIC Mock - Generated by LLM\n"
        f"version: 1.0.0\n"
        f"createdAt: {today}\n"
        f"language: en\n"
        f"explanationsLanguage: ja\n"
        f"part: {part} (5|6|7 only)\n"
        f"per_part: 1\n"
        f"seed: {seed}\n"
        f"p7_length: {p7_length} (short|medium|long)\n"
        "Produce one realistic TOEIC-style reading question.\n"
        "Guidance:\n"
        "- For part 5, write a single sentence with a blank and 4 options; focus on grammar/usage consistent with the domain.\n"
        "- For part 6, write a short single-paragraph document (memo/notice/email/etc.) with one blank marked as 【_____】 and 4 options.\n"
        "- For part 7, write a passage (length per p7_length). If genre is specified, format as that document type (e.g., 'Press Release:', 'Policy:', 'Invoice:', 'Menu:', 'Event:', 'Weather Alert:', 'Job Posting:', 'Parking Rates:', 'Post:', 'Interview Schedule:', 'Newsletter:')." + extra_str
    )


def _parse_json_from_content(content: str) -> Dict[str, Any]:
    """Best-effort JSON extraction from LLM responses.

    Tries strict JSON first; then code-fence extraction; then balanced-brace scan.
    Raises an error if all strategies fail.
    """
    text = (content or "").strip()
    if not text:
        raise ValueError("Empty content")

    # 1) direct parse
    try:
        return json.loads(text)
    except Exception:
        pass

    # 2) fenced code block (```json ... ``` or ``` ... ```)
    import re
    fence = re.search(r"```(?:json)?\s*([\s\S]*?)```", text, flags=re.IGNORECASE)
    if fence:
        inner = fence.group(1).strip()
        try:
            return json.loads(inner)
        except Exception:
            m = re.search(r"\{[\s\S]*\}", inner)
            if m:
                return json.loads(m.group(0))

    # 3) find first balanced JSON object in the whole text
    first = text.find("{")
    if first != -1:
        depth = 0
        for i, ch in enumerate(text[first:], start=first):
            if ch == '{':
                depth += 1
            elif ch == '}':
                depth -= 1
                if depth == 0:
                    candidate = text[first:i + 1]
                    try:
                        return json.loads(candidate)
                    except Exception:
                        break

    # 4) last-resort: greedy braces
    m2 = re.search(r"\{[\s\S]*\}", text)
    if m2:
        return json.loads(m2.group(0))

    # give up with context
    raise ValueError("Failed to parse JSON from content (length=%d)" % len(text))


def generate_dataset_openai(
    title: str,
    part: int,
    seed: int | None,
    p7_length: str,
    model: str = "gpt-4o",
    api_key: Optional[str] = None,
    difficulty: Optional[str] = None,
    genre: Optional[str] = None,
    domain: Optional[str] = None,
) -> Dataset:
    # 優先順位: 引数 > 環境変数
    api_key = api_key or os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise RuntimeError(_OPENAI_MISSING)

    system = _build_system_prompt()
    user = _build_user_prompt(part, seed, p7_length or "long", difficulty=difficulty, genre=genre, domain=domain)

    content: str | None = None

    # バージョンに応じて API を使い分ける
    try:
        import openai  # type: ignore
        ver = getattr(openai, "__version__", "1.0.0")
    except Exception as e:
        raise RuntimeError(f"OpenAI ライブラリの import に失敗しました: {e}\n{_OPENAI_MISSING}")

    def _raise_model_hint(e: Exception) -> RuntimeError:
        return RuntimeError(
            "OpenAI へのリクエストに失敗しました: "
            f"{e}\n利用モデルが存在しない/権限がない可能性があります。"
            "'gpt-4o' や 'gpt-4o' をお試しください。"
        )

    # openai>=1: 新 API を使用
    from packaging import version as _v  # type: ignore
    if _v.parse(ver) >= _v.parse("1.0.0"):
        try:
            from openai import OpenAI  # type: ignore
            client = OpenAI(api_key=api_key)
            # First try with JSON response format (if model supports it)
            try:
                resp = client.chat.completions.create(
                    model=(model or "gpt-4o"),
                    messages=[
                        {"role": "system", "content": system},
                        {"role": "user", "content": user},
                    ],
                    temperature=0.7,
                    response_format={"type": "json_object"},
                )
            except Exception:
                # Retry without forcing JSON mode
                resp = client.chat.completions.create(
                    model=(model or "gpt-4o"),
                    messages=[
                        {"role": "system", "content": system},
                        {"role": "user", "content": user},
                    ],
                    temperature=0.7,
                )
            content = resp.choices[0].message.content  # type: ignore[attr-defined]
        except Exception as e:
            # 新 API で失敗した場合は旧 API にはフォールバックしない（互換性なしのため）
            raise _raise_model_hint(e)
    else:
        # openai<1: 旧 API
        try:
            import openai  # type: ignore  # noqa: F811
            openai.api_key = api_key
            resp = openai.ChatCompletion.create(
                model=(model or "gpt-3.5-turbo"),
                messages=[
                    {"role": "system", "content": system},
                    {"role": "user", "content": user},
                ],
                temperature=0.7,
            )
            content = resp["choices"][0]["message"]["content"]
        except Exception as e:
            raise _raise_model_hint(e)

    if not content:
        raise RuntimeError("OpenAI から空の応答が返りました。")

    data = _parse_json_from_content(content)

    # 最低限のフィールド補完
    data.setdefault("title", title)
    data.setdefault("version", "1.0.0")
    data.setdefault("language", "en")
    data.setdefault("explanationsLanguage", "ja")
    data.setdefault("createdAt", _dt.date.today().isoformat())
    data.setdefault("metadata", {}).setdefault("noteJa", "LLM により生成されたオリジナル問題です。")

    return data
